// Bubble-sort of 10 element array, Mem[0],Mem[8],..Mem[72]
// for (X0 = 9; X0 > 0; X0--) {
//   for (X1 = 0; X1 < X0; X1++) {
//     if (A[X1+1] < A[X1]) SWAP(A[X1+1],A[X1]);
//   }
// }

// Requires:
// ADDI, ADDS, B, B.LT, CBZ, LDUR, STUR & SUBS instructions
// Expected results:
// X11      =  1
// X12      =  2
// X13      =  3
// X14      =  4
// X15      =  5
// X16      =  6
// X17      =  7
// X18      =  8
// X19      =  9
// X20      = 10

//ADDI: I-type, Reg[Rd] = Reg[Rn] + {'0, Imm12}
//OP         Imm12        Rn    Rd
//3322222222 221111111111 00000 00000
//1098765432 109876543210 98765 43210
//1001000100 Unsigned     0..31 0..31

//B: B-type, PC = PC + SignExtend({Imm26, 2'b00})
//OP     Imm26
//332222 22222211111111110000000000
//109876 54321098765432109876543210
//000101 2's Comp Imm26

//B.cond: CB-type, if (flags meet condition) PC = PC + SignExtend({Imm19, 2'b00})
//OP       Imm19               Cond
//33222222 2222111111111100000 00000
//10987654 3210987654321098765 43210
//01010100 2's Comp Imm19      0..15

//CBZ: CB-type, if (R[Rt] == 0) PC = PC + SignExtend({Imm19, 2'b00})
//OP       Imm19               Rt
//33222222 2222111111111100000 00000
//10987654 3210987654321098765 43210
//10110100 2's Comp Imm19      0..31

//LDUR: D-type, Reg[Rt] = Mem[Reg[Rn] + SignExtend(Imm9)]
//OP          Imm9      00 Rn    Rt
//33222222222 211111111 11 00000 00000
//10987654321 098765432 10 98765 43210
//11111000010 2's Comp  00 0..31 0..31

//STUR: D-type, Mem[Reg[Rn] + SignExtend(Imm9)] = Reg[Rt]
//OP          Imm9      00 Rn    Rt
//33222222222 211111111 11 00000 00000
//10987654321 098765432 10 98765 43210
//11111000000 2's Comp  00 0..31 0..31

//SUBS: R-type, Reg[Rd] = Reg[Rn] - Reg[Rm]
//OP          Rm    Shamt  Rn    Rd
//33222222222 21111 111111 00000 00000
//10987654321 09876 543210 98765 43210
//11101011000 0..31 000000 0..31 0..31

         // STOREVALS:
10010001000000000010101111100000    // ADDI X0, X31, #10
11111000000000000000001111100000   // STUR X0, [X31, #0]   // Mem[0] = 10
10010001000000000001111111100000    // ADDI X0, X31, #7
11111000000000001000001111100000   // STUR X0, [X31, #8]   // Mem[8] = 7
10010001000000000001001111100000    // ADDI X0, X31, #4
11111000000000010000001111100000   // STUR X0, [X31, #16]  // Mem[16] = 4
10010001000000000010011111100000    // ADDI X0, X31, #9
11111000000000011000001111100000   // STUR X0, [X31, #24]  // Mem[24] = 9
10010001000000000000111111100000    // ADDI X0, X31, #3
11111000000000100000001111100000   // STUR X0, [X31, #32]  // Mem[32] = 3
10010001000000000010001111100000    // ADDI X0, X31, #8
11111000000000101000001111100000   // STUR X0, [X31, #40]  // Mem[40] = 8
10010001000000000000101111100000    // ADDI X0, X31, #2
11111000000000110000001111100000   // STUR X0, [X31, #48]  // Mem[48] = 2
10010001000000000001011111100000    // ADDI X0, X31, #5
11111000000000111000001111100000   // STUR X0, [X31, #56]  // Mem[56] = 5
10010001000000000001101111100000    // ADDI X0, X31, #6
11111000000001000000001111100000   // STUR X0, [X31, #64]  // Mem[64] = 6
10010001000000000000011111100000    // ADDI X0, X31, #1
11111000000001001000001111100000   // STUR X0, [X31, #72]  // Mem[72] = 1
   // MAIN:
10010001000000000000011111100101    // ADDI X5, X31, #1     // Need a constant 1 for decr
10010001000000000010011111100000    // ADDI X0, X31, #9     // for (X0 = 9; X0 > 0; X0--) {
   // OUTERLOOP:
10010001000000000000001111100001    // ADDI X1, X31, #0     // for (X1 = 0; X1 < X0; X1++) {
10101011000000010000000000100100   // ADDS X4, X1, X1      // For addressing, X4=8*X1
   // INNERLOOP:
11111000010000001000000010000011   // LDUR X3, [X4, #8]    // get A[X1+1]
11111000010000000000000010000010   // LDUR X2, [X4, #0]    // get A[X1]  
10010001000000000000001111111111    // ADDI X31, X31, #0    // NOOP             
11101011000000110000000001011111   // SUBS X31, X2, X3     // Test X2 vs. X3
01010100000000000000000010001011     // B.LT NOSWAP         // Don't swap if X2 < X3
10010001000000000000001111111111    // ADDI X31, X31, #0    // NOOP
11111000000000001000000010000010   // STUR X2, [X4, #8]    // swap A[X1]
11111000000000000000000010000011   // STUR X3, [X4, #0]    // swap A[X1-1]
   // NOSWAP:
10010001000000000000010000100001    // ADDI X1, X1, #1      // X1++
10010001000000000010000010000100    // ADDI X4, X4, #8      // Keep X4=8*X1
11101011000000000000000000111111   // SUBS X31, X1, X0     // Is X1 < X0?
01010100111111111111111010101011     // B.LT INNERLOOP      // If so, continue inner loop
10010001000000000000001111111111    // ADDI X31, X31, #0    // NOOP
   // DONEINNER:
11101011000001010000000000000000   // SUBS X0, X0, X5      // X0--
10110100000000000000000010000000     // CBZ X0, DONEOUTER   // End outer loop when done
10010001000000000000001111111111    // ADDI X31, X31, #0    // NOOP
00010111111111111111111111101110      // B OUTERLOOP         // Continue outer loop
10010001000000000000001111111111    // ADDI X31, X31, #0    // NOOP
   // DONEOUTER:
11111000010000000000001111101011   // LDUR X11, [X31, #0]  // Read back values to regs X11-X20
11111000010000001000001111101100   // LDUR X12, [X31, #8]
11111000010000010000001111101101   // LDUR X13, [X31, #16]
11111000010000011000001111101110   // LDUR X14, [X31, #24]
11111000010000100000001111101111   // LDUR X15, [X31, #32]
11111000010000101000001111110000   // LDUR X16, [X31, #40]
11111000010000110000001111110001   // LDUR X17, [X31, #48]
11111000010000111000001111110010   // LDUR X18, [X31, #56]
11111000010001000000001111110011   // LDUR X19, [X31, #64]
11111000010001001000001111110100   // LDUR X20, [X31, #72]
   // HALT:
00010100000000000000000000000000      // B HALT               // HALT
10010001000000000000001111111111    // ADDI X31, X31, #0    // NOOP
