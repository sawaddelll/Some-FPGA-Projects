// Test of CRC-16 computation on a sample string.

//#define CRCPOLY 0xA001
//int crc16bit(unsigned char *buffer, int length) {
// int i, j;
// unsigned int crcreg = 0;
//
// for (j = 0; j < length; ++j) {
//    unsigned char b = buffer[j];
//    for (i = 0; i < 8; ++i) {
//       if ((crcreg ^ b) & 1) {
//          crcreg = (crcreg >> 1) ^ CRCPOLY;
//       } else {
//          crcreg >>= 1;
//       }
//       b >>= 1;
//    }
// }
// return crcreg;
//}

// Requires:
// ADDI, ADDS, AND, B, CBZ, EOR, LSR & SUBS instructions
// Expected results (HEX):
//X0  = 0xA001 (CRC polynomial)
//X1  = 0x9476 (CRC for string "String 01234")
//X2  = 0xC
//X3  = 0x60
//X4  = 0x8
//X5  = 0x0
//X6  = 0x1
//X7  = 0x0
//X8  = 0x1
//X9  = 0xC
//X10 = 0x8

//ADDI: I-type, Reg[Rd] = Reg[Rn] + {'0, Imm12}
//OP         Imm12        Rn    Rd
//3322222222 221111111111 00000 00000
//1098765432 109876543210 98765 43210
//1001000100 Unsigned     0..31 0..31

//AND: R-type, Reg[Rd] = Reg[Rn] & Reg[Rm]
//OP          Rm    Shamt  Rn    Rd
//33222222222 21111 111111 00000 00000
//10987654321 09876 543210 98765 43210
//10001010000 0..31 000000 0..31 0..31

//B: B-type, PC = PC + SignExtend({Imm26, 2'b00})
//OP     Imm26
//332222 22222211111111110000000000
//109876 54321098765432109876543210
//000101 2's Comp Imm26

//B.cond: CB-type, if (flags meet condition) PC = PC + SignExtend({Imm19, 2'b00})
//OP       Imm19               Cond
//33222222 2222111111111100000 00000
//10987654 3210987654321098765 43210
//01010100 2's Comp Imm19      0..15
// Cond  Name Meaning after SUBS FlagTest
// 01011 LT    Signed <        N!=V

//CBZ: CB-type, if (R[Rt] == 0) PC = PC + SignExtend({Imm19, 2'b00})
//OP       Imm19               Rt
//33222222 2222111111111100000 00000
//10987654 3210987654321098765 43210
//10110100 2's Comp Imm19      0..31

//EOR: R-type, Reg[Rd] = Reg[Rn] ^ Reg[Rm]
//OP          Rm    Shamt  Rn    Rd
//33222222222 21111 111111 00000 00000
//10987654321 09876 543210 98765 43210
//11001010000 0..31 000000 0..31 0..31

//LDUR: D-type, Reg[Rt] = Mem[Reg[Rn] + SignExtend(Imm9)]
//OP          Imm9      00 Rn    Rt
//33222222222 211111111 11 00000 00000
//10987654321 098765432 10 98765 43210
//11111000010 2's Comp  00 0..31 0..31

//LSR: R-type, Reg[Rd] = Reg[Rn] >> shamt (no sign extend)
//OP          Rm    Shamt  Rn    Rd
//33222222222 21111 111111 00000 00000
//10987654321 09876 543210 98765 43210
//11010011010 00000 0...63 0..31 0..31

//STUR: D-type, Mem[Reg[Rn] + SignExtend(Imm9)] = Reg[Rt]
//OP          Imm9      00 Rn    Rt
//33222222222 211111111 11 00000 00000
//10987654321 098765432 10 98765 43210
//11111000000 2's Comp  00 0..31 0..31

//SUBS: R-type, Reg[Rd] = Reg[Rn] - Reg[Rm]
//OP          Rm    Shamt  Rn    Rd
//33222222222 21111 111111 00000 00000
//10987654321 09876 543210 98765 43210
//11101011000 0..31 000000 0..31 0..31

            // BUILDSTRING:
10010001000000010100111111100000    // ADDI X0, X31, #83       // X0: 'S'
11111000000000000000001111100000   // STUR X0, [X31, #0]      // Mem[0] = 'S'
10010001000000011101001111100000    // ADDI X0, X31, #116      // X0: 't'
11111000000000001000001111100000   // STUR X0, [X31, #8]      // Mem[8] = 't'
10010001000000011100101111100000    // ADDI X0, X31, #114      // X0: 'r'
11111000000000010000001111100000   // STUR X0, [X31, #16]     // Mem[16] = 'r'
10010001000000011010011111100000    // ADDI X0, X31, #105      // X0: 'i'
11111000000000011000001111100000   // STUR X0, [X31, #24]     // Mem[24] = 'i'
10010001000000011011101111100000    // ADDI X0, X31, #110      // X0: 'n'
11111000000000100000001111100000   // STUR X0, [X31, #32]     // Mem[32] = 'n'
10010001000000011001111111100000    // ADDI X0, X31, #103      // X0: 'g'
11111000000000101000001111100000   // STUR X0, [X31, #40]     // Mem[40] = 'g'
10010001000000001000001111100000    // ADDI X0, X31, #32       // X0: ' '
11111000000000110000001111100000   // STUR X0, [X31, #48]     // Mem[48] = ' '
10010001000000001100001111100000    // ADDI X0, X31, #48       // X0: '0'
11111000000000111000001111100000   // STUR X0, [X31, #56]     // Mem[56] = '0'
10010001000000001100011111100000    // ADDI X0, X31, #49       // X0: '1'
11111000000001000000001111100000   // STUR X0, [X31, #64]     // Mem[64] = '1'
10010001000000001100101111100000    // ADDI X0, X31, #50       // X0: '2'
11111000000001001000001111100000   // STUR X0, [X31, #72]     // Mem[72] = '2'
10010001000000001100111111100000    // ADDI X0, X31, #51       // X0: '3'
11111000000001010000001111100000   // STUR X0, [X31, #80]     // Mem[80] = '3'
10010001000000001101001111100000    // ADDI X0, X31, #52       // X0: '4'
11111000000001011000001111100000   // STUR X0, [X31, #88]     // Mem[88] = '4'
            // BUILDPOLY:
10010001000000000000001111100000    // ADDI X0, X31, #0        // for (i = 0; i < 10; i++)
10010001000000000010101111100001    // ADDI X1, X31, #10
10010001000000000000001111100010    // ADDI X2, X31, #0
10010001001111111111110001000010    // ADDI X2, X2, #4095
10010001000000000000010000000000    // ADDI X0, X0, #1         // i++
11101011000000010000000000011111   // SUBS X31, X0, X1        // is i < 10?
01010100111111111111111110101011     // B.LT BUILDPOLY+3       // If so, continue loop
10010001000000000000001111111111    // ADDI X31, X31, #0       // NOOP
10010001000000000010110001000010    // ADDI X2, X2, #11
            // MAIN:
10010001000000000000000001000000    // ADDI X0, X2, #0         // X0: #define CRCPOLY 0xA001
10010001000000000000001111100001    // ADDI X1, X31, #0        // X1: unsigned int crcreg = 0;
10010001000000000000011111101000    // ADDI X8, X31, #1        // Need a constant 1 for &
10010001000000000011001111101001    // ADDI X9, X31, #12       // Need a constant 12 for branch check
10010001000000000010001111101010    // ADDI X10, X31, #8       // Need a constant 8 for branch check
10010001000000000000001111100010    // ADDI X2, X31, #0        // for (j = 0; j < 12; ++j) {
10010001000000000000001111100011    // ADDI X3, X31, #0        // For addressing, X3=8*X2
            // OUTERLOOP:
10010001000000000000001111100100    // ADDI X4, X31, #0        // for (i = 0; i < 8; ++i) {
11111000010000000000000001100101   // LDUR X5, [X3, #0]       // unsigned char b = buffer[j];
10010001000000000000001111111111    // ADDI X31, X31, #0       // NOOP
            // INNERLOOP:
11001010000000010000000010100110   // EOR X6, X5, X1          // crcreg ^ b
10001010000010000000000011000110   // AND X6, X6, X8          // (crcreg ^ b) & 1
11101011000010000000000011000111   // SUBS X7, X6, X8         // if ((crcreg ^ b) & 1)
10110100000000000000000010100111     // CBZ X7, SHIFTCRCREG (+5)
10010001000000000000001111111111    // ADDI X31, X31, #0       // NOOP
            // ELSE:
11010011010000000000010000100001   // LSR X1, X1, #1          // crcreg >>= 1;
00010100000000000000000000000100      // B SHIFTB (+4)
10010001000000000000001111111111    // ADDI X31, X31, #0       // NOOP
            // SHIFTCRCREG:
11010011010000000000010000100001   // LSR X1, X1, #1          // crcreg >>= 1;
11001010000000000000000000100001   // EOR X1, X1, X0          // crcreg = crcreg ^ CRCPOLY
            // SHIFTB:
11010011010000000000010010100101   // LSR X5, X5, #1          // b >>= 1;
10010001000000000000010010000100    // ADDI X4, X4, #1         // i++
11101011000010100000000010011111   // SUBS X31, X4, X10       // is i < 8?
01010100111111111111111001101011     // B.LT INNERLOOP (-13)   // If so, continue inner loop
10010001000000000000001111111111    // ADDI X31, X31, #0       // NOOP
            // DONEINNER:
10010001000000000000010001000010    // ADDI X2, X2, #1         // j++
10010001000000000010000001100011    // ADDI X3, X3, #8         // Keep X3=8*X2
11101011000010010000000001011111   // SUBS X31, X2, X9        // is j < 12?
01010100111111111111110101101011     // B.LT OUTERLOOP (-21)   // If so, continue outer loop
10010001000000000000001111111111    // ADDI X31, X31, #0       // NOOP
            // HALT:
00010100000000000000000000000000      // B HALT                  // HALT
10010001000000000000001111111111    // ADDI X31, X31, #0       // NOOP